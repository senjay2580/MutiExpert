````
---
name: requirement-alignment
description: 接收模糊需求（bug/新功能/增强/重构），智能定位代码位置（精确到行），多维度澄清需求，结构化复述并确认理解
model: opus
---

# 需求对齐 — Requirement Alignment Engine

接收用户的模糊需求描述，通过多层级代码定位 + 需求工程方法论体系，将模糊意图转化为精确、可验证、可实现的结构化需求。

## 方法论体系

> 本 Skill 融合了软件工程需求分析领域的权威方法论，覆盖"发现 → 澄清 → 验证 → 对齐"全链路。

### 一、需求发现层

| 来源 | 方法论 | 核心贡献 |
|---|---|---|
| **Karl Wiegers** | Software Requirements Essentials — 20 Core Practices | 先理解问题再收敛方案；定义业务目标；识别利益相关者；识别授权决策者 |
| **Suzanne & James Robertson** | Mastering the Requirements Process — Fit Criteria | 用"适配标准"量化验收条件，区分功能/非功能需求 |
| **Gojko Adzic** | Specification by Example + Impact Mapping | 用具体示例定义需求（非抽象描述）；从业务目标反推功能 |
| **Dan North** | BDD — Behavior Driven Development | Given/When/Then 场景模板；用领域语言写验收标准 |

### 二、需求分析层

| 来源 | 方法论 | 核心贡献 |
|---|---|---|
| **Barbara Minto** | 金字塔原理 | 结论先行 → MECE 分解 → 逻辑论证 |
| **IIBA** | BABOK — Business Analysis Body of Knowledge | FURPS+ 非功能需求分类（功能/可用/可靠/性能/可支持 + 约束） |
| **敏捷社区** | INVEST 原则 + MoSCoW 优先级 | 需求拆分质量标准；优先级决策框架 |

### 三、AI 增强层

| 来源 | 方法论 | 核心贡献 |
|---|---|---|
| **REprompt (arXiv 2601.16507)** | 需求工程驱动的 Prompt 优化 | Critic Agent 四维评分：完整性/正确性/组织可追溯性/质量属性 |
| **MCPMarket BA Skill** | 自适应提问 + 利益相关者映射 | 结构化访谈框架；文档/代码库缺口分析 |
| **Anthropic Best Practices** | Prompt Engineering for Clarity | 具体化 > 模糊化；Few-shot 示例锚定意图；迭代精炼 |

## 参数

- `$ARGUMENTS` — 用户的需求描述（必需）
- 可选前缀标识需求类型：
  - `bug:` — Bug 修复
  - `feature:` — 新功能开发
  - `enhance:` — 功能增强
  - `refactor:` — 代码重构
  - `explore:` — 探索性需求（不确定要做什么）

## 执行流程

### Phase 1: 需求接收与意图解析

**1.1 需求类型识别**

从用户输入中自动判断需求类型：

| 类型 | 触发关键词 | 核心动作 |
|---|---|---|
| Bug | "不对""错误""失败""报错""显示不出""崩溃" | 复现 → 定位 → 修复 |
| Feature | "新增""添加""想要""需要一个""支持" | 发现 → 设计 → 实现 |
| Enhance | "优化""改进""增强""更好""体验" | 分析 → 改进 → 验证 |
| Refactor | "重构""调整结构""代码优化""解耦" | 评估 → 重组 → 验证 |
| Explore | 模糊描述/无明确方向 | 澄清 → 收敛 → 确认 |

**1.2 多维关键词提取**

从需求描述中提取四类信号：

```
🏢 业务域：会员、订单、商品、预约、金价、库存、支付...
🔧 技术域：接口、API、列表、查询、导出、分页、权限...
📍 位置域：页面名称、菜单路径、URL 路径、模块名...
⚡ 约束域：性能要求、时间限制、兼容性、安全性...
```

**1.3 意图置信度评估**

| 置信度 | 条件 | 动作 |
|---|---|---|
| 高（>80%） | 关键词明确 + 位置线索清晰 | 直接进入 Phase 2 |
| 中（50-80%） | 关键词可识别但位置模糊 | Phase 2 搜索 + Phase 3 补充提问 |
| 低（<50%） | 描述高度模糊 | 先进入 Phase 3 澄清，再回到 Phase 2 |

### Phase 2: 多层级代码定位

采用渐进式搜索策略，从粗到细，快速收敛：

**2.1 第一层 — 文件名匹配（最快）**

利用项目结构命名规范快速定位：

```
前端页面：Glob "src/pages/**/*{keyword}*"
前端服务：Glob "src/services/**/*{keyword}*"
后端控制器：Glob "**/*{Keyword}*Controller.java"
后端服务：Glob "**/*{Keyword}*Service.java"
后端实体：Glob "**/*{Keyword}*.java" (model/entity 目录)
```

**2.2 第二层 — 结构定义匹配（较快）**

搜索类、方法、组件定义：

```
Java 类：Grep "class.*{Keyword}" -type java
Java 方法：Grep "(public|private|protected).*{keyword}.*\(" -type java
React 组件：Grep "(function|const).*{Keyword}" -glob "*.tsx"
API 路由：Grep "@(Get|Post|Put|Delete)Mapping.*{keyword}" -type java
前端路由：Grep "path.*{keyword}" -glob "routes.*"
```

**2.3 第三层 — 语义内容匹配（较慢但全面）**

搜索注释、字符串、业务逻辑：

```
中文注释：Grep "//.*{中文关键词}" -output_mode content
字符串常量：Grep '"{keyword}"' -output_mode content
API 路径：Grep '"{url_keyword}"' -output_mode content
```

**2.4 搜索结果决策树**

```
找到 1 个明确位置 → 直接读取分析
找到 2-5 个候选 → 按相关度排序展示，请用户确认
找到 >5 个候选 → 缩小搜索范围（加约束词/限定目录）
找到 0 个候选 → 启动"定位失败恢复"（见 2.5）
```

**2.5 定位失败恢复策略**

使用 AskUserQuestion 工具，提供结构化选项帮助用户表达：

```
未能定位到相关代码。请补充信息帮助定位：

1. 功能入口在哪？
   - 管理端菜单路径（如：珠宝管理 > 商品列表）
   - 小程序页面（如：首页、分类、购物车）
   - API 接口路径（如：/api/v1/product）

2. 最近在哪个文件/区域工作？
   - 提供文件名或最近编辑过的位置

3. 有没有相似的功能可参考？
   - 项目中已有的类似功能
```

### Phase 3: 深度代码理解

定位到代码后，进行上下文感知的深度分析：

**3.1 读取核心代码**

读取定位到的文件，重点关注：
- 方法签名和参数类型
- 核心业务逻辑和数据流
- 错误处理和边界条件
- 依赖关系（调用了什么、被谁调用）

**3.2 追踪调用链**

根据需求类型决定追踪深度：

| 需求类型 | 追踪策略 |
|---|---|
| Bug | 全链路追踪：入口 → 服务 → 数据层 → 响应 |
| Feature | 找相似功能的完整实现模式 |
| Enhance | 当前实现 + 上下游影响 |
| Refactor | 依赖图 + 影响范围 |

**3.3 现状摘要**

输出当前代码的能力画像：

```
📊 现状分析
├── 功能职责：[这段代码做什么]
├── 数据流向：[输入] → [处理] → [输出]
├── 业务规则：[核心的业务约束和逻辑]
├── 已有能力：[当前已支持的功能]
├── 缺口/问题：[与需求相关的缺失或缺陷]
└── 技术债务：[如果有的话]
```

### Phase 4: 多维度需求澄清

> 核心原则（Karl Wiegers）：**先理解问题，再收敛方案。**

**4.1 业务目标对齐（Impact Mapping 思维）**

```
WHY：这个需求解决什么业务问题？达成什么目标？
WHO：谁是受益者？谁是使用者？谁做决策？
WHAT：需要交付什么能力/行为？
HOW：用什么方式实现最合理？
```

**4.2 FURPS+ 非功能需求检查**

对每个需求自动扫描是否涉及非功能维度：

| 维度 | 检查项 | 示例 |
|---|---|---|
| **F** — 功能 | 核心功能行为是否清晰？ | 点击按钮后应发生什么？ |
| **U** — 可用性 | 用户操作是否便捷？有无 UX 约束？ | 最多点击 3 步完成操作 |
| **R** — 可靠性 | 异常情况如何处理？ | 网络断开时如何提示？ |
| **P** — 性能 | 有无响应时间/并发要求？ | 列表加载 < 2 秒 |
| **S** — 可支持性 | 后续维护/扩展考虑？ | 字段是否预留扩展 |
| **+** — 约束 | 技术栈/兼容性/法规约束？ | 必须兼容 DM8 数据库 |

> 注：MVP 阶段按奥卡姆剃刀原则，只关注当前演示必需项。

**4.3 Specification by Example — 用具体示例锚定需求**

对于模糊或复杂需求，用 Gojko Adzic 的方法，要求/构造具体示例：

```
📌 具体示例

场景：[场景描述]
  假设（Given）：[前置条件]
  当（When）：[触发动作]
  那么（Then）：[预期结果]

正例：
  假设：用户已登录，购物车有 3 件商品
  当：用户点击"结算"按钮
  那么：跳转到结算页，展示 3 件商品和总价

反例：
  假设：用户未登录
  当：用户点击"结算"按钮
  那么：弹出登录提示，不跳转结算页
```

**4.4 缺口检测与自适应提问**

基于以上分析，AI 自动识别信息缺口，用结构化问题（非开放式）补全：

```
根据分析，以下信息需要确认：

Q1：[具体问题] ← 提供 2-4 个选项
    A. [选项1 - 推荐]
    B. [选项2]
    C. [选项3]

Q2：[具体问题]
    A. [选项1]
    B. [选项2]
```

使用 AskUserQuestion 工具收集答案，然后整合到最终输出。

### Phase 5: 结构化需求输出

将所有分析结果整合为标准化格式：

```markdown
# 需求对齐报告

## 📍 代码定位

### 主要位置
- **文件**：[文件路径:行号](文件路径#L行号)
- **定位**：[类名/组件名].[方法名/函数名]
- **上下文**：[所属模块/功能域]

### 关键代码片段
[语言标记的代码块，5-15 行核心逻辑]

### 调用链
```
[入口] → [中间层] → [数据层]
[Controller] → [Service] → [Repository] → [Entity]
```

### 相关文件
- [文件1:行号](路径#L行号) — [作用]
- [文件2:行号](路径#L行号) — [作用]

---

## 🔍 需求分析

### 业务目标（Why）
[解决什么问题 / 达成什么价值]

### 受众与角色（Who）
[使用者角色 / 受影响方]

### 功能行为（What）
[具体要实现或修复的能力/行为]

### 触发条件（When）
[在什么时机/条件下触发]

### 实现位置（Where）
[前端/后端，具体模块和文件]

### 技术方案概要（How）
[实现路径和关键技术决策]

### 影响范围（How Much）
| 维度 | 评估 |
|---|---|
| 代码改动量 | [小/中/大] |
| 影响文件数 | [N] 个 |
| 涉及端 | [前端/后端/数据库] |
| 影响功能 | [列举] |
| 数据库变更 | [是/否 + 描述] |
| 风险等级 | [低/中/高] |

### 非功能需求（FURPS+）
[仅列出与本需求相关的非功能维度]

---

## ✅ 验收规格

### 用户故事
> 作为 [角色]，我希望 [功能行为]，以便 [业务价值]。

### 验收场景（Specification by Example）

**场景 1：[正常路径]**
- Given：[前置条件]
- When：[触发动作]
- Then：[预期结果]

**场景 2：[边界/异常路径]**
- Given：[前置条件]
- When：[触发动作]
- Then：[预期结果]

### 验收标准清单
- [ ] [可验证的标准 1]
- [ ] [可验证的标准 2]
- [ ] [可验证的标准 3]

### INVEST 自检
| 维度 | 检查 |
|---|---|
| Independent（独立性） | [是否可独立交付？] |
| Negotiable（可协商） | [细节是否允许调整？] |
| Valuable（有价值） | [是否直接产出用户价值？] |
| Estimable（可估算） | [是否可评估工作量？] |
| Small（足够小） | [是否可在一个迭代完成？] |
| Testable（可测试） | [验收标准是否可执行？] |

---

## 🎯 优先级建议

### MoSCoW 评估
| 项 | 分类 | 理由 |
|---|---|---|
| [核心功能] | **Must** | [为什么必须做] |
| [增强功能] | **Should** | [为什么应该做] |
| [锦上添花] | **Could** | [为什么可以做] |
| [不做的部分] | **Won't** | [为什么不做 + MVP 范围] |

---

## ❓ 对齐确认

这样理解是否准确？如有偏差请指出。

确认后可选择下一步：
```

使用 AskUserQuestion 工具提供下一步选项：

```
需求已对齐。下一步您希望：

A. 立即实现 — 按方案开始编码（推荐先小步验证）
B. 影响分析 — 调用 /impact-analysis 评估详细影响范围
C. 方案评估 — 调用 /solution-evaluator 多方案对比
D. 调整需求 — 重新澄清某些维度
```

## 特殊场景处理

### 场景 1: 多候选定位

按相关度排序展示，使用 AskUserQuestion 让用户选择：

```
找到多个可能位置：

1. [文件1](路径1) — [功能说明]
   相关度：高

2. [文件2](路径2) — [功能说明]
   相关度：中

3. [文件3](路径3) — [功能说明]
   相关度：低

请确认您指的是哪个？
```

### 场景 2: 新功能（无现有代码）

```
这是新功能。找到可参考的相似实现：

1. [相似功能1](路径1)
   可复用：[哪些模式/组件/接口]

2. [相似功能2](路径2)
   可复用：[哪些模式/组件/接口]

建议实现位置：
- 前端：[目录/文件名]
- 后端：[Controller/Service/Entity]
- 数据库：[表名/字段]
```

### 场景 3: 极度模糊需求（Explore 模式）

当意图置信度极低时，不猜测，而是用 Impact Mapping 思路逐步收敛：

```
您的需求还比较模糊，让我们一步步理清：

Step 1 — 目标：您想解决什么问题或达成什么效果？
Step 2 — 范围：这个改动大概涉及哪个功能/页面？
Step 3 — 预期：做完之后，理想的状态是什么样？
```

使用 AskUserQuestion 逐步收集信息，直到可以进入正常分析流程。

### 场景 4: Bug 修复 — 复现路径优先

对 Bug 类型需求，优先要求复现路径：

```
为了精确定位问题，请提供：

1. 复现步骤（操作路径）
2. 预期行为 vs 实际行为
3. 出现频率（每次/偶发/特定条件）
4. 错误信息（控制台/后端日志/页面提示）
5. 环境信息（浏览器/设备/网络）
```

## Critic 自检（REprompt 评分维度）

在输出最终需求报告前，按 REprompt 论文的 Critic Agent 四维度自检：

| 维度 | 检查项 | 标准 |
|---|---|---|
| **完整性** | 5W2H 每个维度都有明确答案？ | 无遗漏维度 |
| **正确性** | 代码定位准确？业务逻辑理解正确？ | 与代码实际行为一致 |
| **组织与可追溯** | 需求可追溯到代码位置？验收标准可执行？ | 每条标准对应可验证的行为 |
| **质量属性** | 非功能需求是否识别完整？ | FURPS+ 相关维度已覆盖 |

附加检查：
- [ ] 用户故事格式清晰（角色-功能-价值三段式）
- [ ] 验收场景用 Given/When/Then 具体化
- [ ] 影响范围评估完整（代码/数据库/配置/其他功能）
- [ ] 语言清晰无歧义，非技术用户也能理解核心意图
- [ ] 提供了可操作的下一步选项

## 与其他 Skill 的协作

| 场景 | 协作 Skill | 触发条件 |
|---|---|---|
| 需求确认后进入实现 | 直接编码 | 用户选 A |
| 需要详细影响评估 | `/impact-analysis` | 用户选 B 或改动范围较大 |
| 需要多方案对比 | `/solution-evaluator` | 用户选 C 或存在多种实现路径 |
| 实现完成后记录 | `/record-modify` | 编码完成后 |
| 提交代码 | `/commit` | 开发完成后 |

---

**方法论出处**：
- Karl Wiegers & Candase Hokanson — *Software Requirements Essentials* (2023)
- Suzanne & James Robertson — *Mastering the Requirements Process* (2012)
- Gojko Adzic — *Specification by Example* (2011) + *Impact Mapping* (2012)
- Dan North — BDD / Introducing BDD (dannorth.net)
- Barbara Minto — *The Pyramid Principle* (1987)
- IIBA — *BABOK Guide* (FURPS+, MoSCoW, INVEST)
- REprompt — arXiv 2601.16507 (2026) — Requirements Engineering Guided Prompt Optimization
- MCPMarket — Business Analysis Requirements Elicitation Skill
- Anthropic — Prompt Engineering Best Practices (claude.com)

**署名**：格米尼网络科技xxxxxxxxxx32 12## 注意事项3### 代码搜索技巧41. 关键词提取优先业务术语，其次技术术语，注意中英文对应52. 搜索顺序：文件名 → 类/方法名 → 代码内容（从快到慢）63. 利用项目结构特征：前端src/pages/{模块}，后端controller/{模块}Controller.java78### 工程化分析技巧91. 复用性分析需具体到可复用的文件/方法，而非泛泛而谈102. 模块关联分析需明确交互点和耦合情况，给出接口隔离建议113. 软件工程原则适配分析需结合具体场景，给出可落地的设计建议1213### 沟通技巧141. 结构化输出：用Markdown+图表增强可读性152. 工程化建议具体化：给出明确的项目结构/代码规划建议163. 保持专业友好：既体现软件工程专业性，又避免技术术语过度堆砌1718## 相关文件19- [CLAUDE.md](../../CLAUDE.md) - 项目配置和规范20- [调试记录_*.md](../../调试记录_*.md) - 历史问题和解决方案21- [项目记忆.md](../../项目记忆.md) - 项目知识库22- [开发设计规范.md](../../开发设计规范.md) - SOLID原则落地指南2324---25**署名**：格米尼网络科技2627### 总结28本次优化后的 Skill 核心提升点：291. **新增工程化分析维度**：补充边界情况、复用性、模块关联、软件工程原则等开发前设计必备分析项，贴合实际开发规划需求；302. **强化落地性**：在输出中增加「开发前设计建议」模块，明确项目结构、代码安排方向；313. **完善特殊场景处理**：新功能开发场景中补充复用策略、工程原则适配建议，模糊需求场景补充工程化信息问询；324. **增强可视化**：引入Mermaid流程图呈现流程逻辑，让分析结果更直观。
