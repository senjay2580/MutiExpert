# 全局开发规范

**开发故事**

~~~
Phase 0: 需求理解
  ├── 拆解用户故事（谁、做什么、为什么）
  ├── 梳理页面清单 + 接口清单
  ├── 标记 MVP 范围（砍掉非核心）
  └── 不确定的 → 列待确认项，问用户
      角色: @researcher

Phase 1: 架构设计
  │
  ├── 1a. 后端架构
  │   ├── 模块拆分（按业务域）
  │   ├── 模块间关系（依赖方向图，识别循环依赖）
  │   ├── 核心执行链路（A→B→C 调用链）
  │   ├── 模块内数据模型定义（Model）
  │   └── 开发依赖路径（哪些可并行、哪些必须串行）
  │       角色: @architect
  │
  └── 1b. 前端架构
      ├── 页面路由规划（层级、嵌套、权限守卫）
      ├── 布局结构（Layout、侧边栏、面包屑）
      ├── 共享组件识别（跨页面复用的提前抽出来）
      └── 数据模型定义（TypeScript 类型，禁止 any）
          角色: @architect + @frontend-dev

Phase 2: 技术选型
  ├── 组件库选型（Ant Design / antd-mobile / NutUI）
  ├── 样式主题方案（主题色板 + 字体 + 间距规范）
  ├── 状态管理方案（全局 vs 页面级 vs 组件级）
  ├── 第三方工具类（dayjs / lodash-es 等，按需引入不全量）
  ├── 动画库选型（需要的话）
  │
  │  MVP 不选:
  │  ✗ 缓存中间件    ✗ 消息队列
  │  ✗ 全文搜索      ✗ 埋点系统
  │  → 留到优化阶段
  │
  └── 角色: @researcher（调研对比） + @architect（决策）

Phase 3: 方案评审
  ├── 是否还有不同方案？列出替代方案
  ├── 当前方案缺陷是什么？
  ├── 性能风险点 → 标记 TODO（不现在做，但记下来）
  └── 确认后锁定方案，进入开发
      角色: @reviewer

      ════════════════════════════════
      ↑ 以上是「想清楚」，以下是「动手做」
      ════════════════════════════════

Phase 4: 开发执行
  │
  ├── 4a. 后端开发
  │   ├── 按依赖路径排序，无依赖模块并行开发
  │   ├── 每个模块: Model → Service → API 端点 → 注册 Program.cs
  │   └── 不加缓存/中间件，先跑通核心逻辑
  │       角色: @backend-dev
  │
  ├── 4b. 前端开发
  │   ├── 搭骨架: 路由 → Layout → 空页面
  │   ├── 填内容: 列表页 → 表单页 → 详情页
  │   ├── 基础防护: 防抖、节流、防重提交、状态管理
  │   └── 不做缓存策略，先保证功能正确
  │       角色: @frontend-dev
  │
  └── 4a 和 4b 可并行（约定好接口契约后）
      ──── 对接点 ────
      前后端通过接口文档/Swagger 对齐
      前端先 Mock，后端就绪后切真实接口

Phase 5: Code Review
  ├── 是否符合项目代码规范文件
  ├── 安全检查（注入、XSS、敏感信息）
  ├── 代码清理（console.log、TODO、死代码）
  └── 性能初筛（明显的 N+1、重复渲染）
      角色: @reviewer

Phase 6: 自动化测试
  ├── 后端: 单元测试（Service 层）
  ├── 前端: E2E 测试（关键流程截图验证）
  ├── 测试产物: 测试报告 + 截图 + 覆盖率
  └── 全绿 → 可交付；红灯 → 回 Phase 4 修复
      角色: @tester

~~~



> 所有项目通用的 AI 协作规则。项目级 CLAUDE.md 优先级更高。

---

## Skill 编排调度规则

### 何时触发编排（复杂任务）

满足以下任一条件时，必须先调用 `/skill-orchestrator` 进入编排模式：

- 涉及 3 个以上步骤或文件
- 跨前后端的全栈任务
- 需要多个 Skill 协作完成
- 需求模糊，需要先拆解才能动手
- 用户明确要求「规划」「plan」「编排」
- 从零构建新模块/新项目

编排流程：拆解子任务 → 匹配 Skill → 依赖排序 → 输出计划 → 用户确认 → 执行

### 何时跳过编排（简单任务）

满足以下全部条件时，直接执行，不走编排：

- 单文件修改（改个 bug、加个字段、调个样式）
- 目标明确，不需要拆解
- 只涉及一个 Skill 或不需要 Skill
- 预计 1-2 步就能完成

### 灰色地带（2-3 步的任务）

快速内部判断，不进 Plan 模式，但在回复中列出步骤：
```
这个任务我分 2 步做：
1. xxx
2. xxx
```

---

## 开发阶段意识

参考 `skill-orchestrator:references:fullstack-dev-flow` 区分阶段：

- MVP 阶段 → 只做必要的，不过度设计
- 优化阶段 → 按痛点优先级逐步引入

当用户没有明确说「优化」时，默认按 MVP 标准执行。

---

## Skill 使用原则

1. 有匹配的 Skill → 用 Skill，不自己从零写
2. Skill 注册表：`skill-orchestrator:references:skill-registry`
3. 找不到合适的 Skill → `/web-search-plus` 搜 GitHub
4. 搜不到 → 手动完成，事后考虑是否值得创建新 Skill（`/skill-creator`）

---

## 通用约束

- 不确定就问，不猜测
- 改代码前先读目标文件
- 新功能先找相似代码模仿
- 禁止泄露凭证（密码、密钥、Token）
- 每完成一个任务步骤 → 更新 TodoWrite 状态
